#!/bin/sh
######################################################################
# LICENSE pulled in with, cat LICENSE  | awk '{print "# "$0}'
######################################################################

# Portions of code modified from the compilation of software known
# as mfsBSD: Copyright (C) 2007-2013 Martin Matuska
#
# They are noted in code comments as beind borrowed of modified
# from https://github.com/mmatuska/mfsbsd
#
# The rest of the code: Copyright (c) 2014, John Ko
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

######################################################################
# Script version is YYmmdd-HHMM in UTC, date +%y%m%d-%H%M%S
######################################################################
SCRIPTVERSION=141214-055648

######################################################################
# Variables you can edit
######################################################################

bename=rfs
bfsname=default
bsize=2g
distsite="http://ftp4.freebsd.org/pub/FreeBSD/releases"
keyfile=/boot/encryption.key
release=10.1-RELEASE
ssize=2g

######################################################################
# Variables you don't touch
######################################################################

align4k="-a 4k"
bpool=bootpool
bsdinstalltmp=/tmp/bsdinstall_boot
bsdinstalletc=/tmp/bsdinstall_etc
crypttmp=/tmp/crypt
datacryptkey=/boot/data.crypt.key
datasizes="3730 3620 2800 2690 1860 1740 940 830" # Preferred descending order
mfsmnt=/mnt2
mfsfile=mfsroot
ntpdate_hosts="pool.ntp.org"
PROMPTCHANGEPASSWD=y
raidtype=stripe
RESTOREMASK=`umask`

######################################################################
######################################################################
# Start of functions
######################################################################
######################################################################

######################################################################
# Usage
######################################################################

usage() {
  cat <<EOF
usage:  ${0##*/} -d disk [-d disk ...] [-e disk]
        [-b boot_size] [-h] [-m] [-M /mnt] [-p poolname]
        [-r stripe|mirror|raidz|raidz2|raidz3] [-s swap_size] [-v]
        [-z pool_size]

        -b size  Boot partition size.
        -c       Configure sshd_config, loader.conf and rc.conf, rc.conf.d.
        -C       Same as -c plus loader.conf.local and rc.conf.local.
        -d disk  Disk to install on (eg. da0).
        -e disk  Attach to this existing disk that is part of -p pool.
        -h       Help.
        -m       Create mfsroot type of system.
        -M mount Mountpoint, if not using /mnt.
        -n       Don't prompt to change password.
        -p name  ZFS pool name, must be unique.
        -r       Select ZFS raid mode if multiple -d given.
        -s size  Swap partition size.
        -v       Version.
        -z size  ZFS pool size.

        ${0##*/} -M [-p poolname]

        -f       Update / make a new mfsroot.

        ${0##*/} -i -d vdev [-d vdev ...] [-p poolname] [-x]
        ${0##*/} -i -e vdev -d vdev [-p poolname]
        ${0##*/} -u -d vdev [-d vdev ...] [-p poolname]
        ${0##*/} -l [-p poolname]

        -i       Initialize data partition with geli and create pool.
                 Automatically create partition 5 unless -x is set.
        -l       Export pool and lock data partition.
        -u       Unlock data partition and mount pool.
        -x       Explicit -d device, don't create partition 5 automatically.
        -d vdev  Virtual device to grab gptid label from (eg. da0p5)

examples:

  Install on disk 0, pool name mini with size 2 GB:
        ${0##*/} -d ada0 -z 2g -p mini

  Add disk 1 as mirror to existing pool mini that contains disk ada0:
        ${0##*/} -e ada0 -d ada1 -z 2g -p mini

  Add data partition automatically and create pool tank:
        ${0##*/} -i -d ada0 -p tank

  Create another data partition and attach to pool tank:
        ${0##*/} -i -e ada0p5 -d ada1 -p tank

other examples:

  Install on 3 mirror disks, a boot pool 1 GB, swap 1 GB, ZFS root pool 2 GB:
        ${0##*/} -d ada0 -d ada1 -d ada2 -b 1g -s 1g -z 2g -r mirror

  Make a bootable ZFS USB, which loads as mfs:
  Note we change the pool name so they don't conflict.
        ${0##*/} -d da0 -m -p usb

  Minimal mirror mfs server:
        ${0##*/} -d ada0 -d ada1 -z 2g -m -p mini

  Create data pool with these devices, no auto partition creation:
        ${0##*/} -i -d ada0p5 -d ada1p5 -p data -x
EOF
}

######################################################################
# Exit function
######################################################################

exiterror() {
  [ "$1" != "0" ] && echo "ERROR: Exit code $1"
  umount ${crypttmp} >/dev/null 2>&1
  umount ${bsdinstalltmp} >/dev/null 2>&1
  exit $1
}

######################################################################
# Exit function
######################################################################

cryptdecode() {
  umask 077
  install -d -m 700 -o root -g wheel ${crypttmp}
  chown root:wheel ${crypttmp}
  chmod 700 ${crypttmp}
  umount ${crypttmp} >/dev/null 2>&1
  mount -t tmpfs tmpfs ${crypttmp}
  TMPFILE=`mktemp ${crypttmp}/crypt.XXXXXX`
  echo -n "Decrypting Password, "
  crypt < ${datacryptkey} >$TMPFILE
  umask $RESTOREMASK
}

######################################################################
# Post-install configuration
######################################################################

freebsdconfigglobal() {
  ########## Set some loader.conf options global to vps hosts too
  sysrc -f "${mnt}/boot/loader.conf" autoboot_delay="1" >/dev/null
  ########## hw.usb.no_shutdown_wait allows USB not to stall poweroff
  sysrc -f "${mnt}/boot/loader.conf" "hw.usb.no_shutdown_wait=1" >/dev/null
  sysrc -f "${mnt}/boot/loader.conf" "kern.cam.boot_delay=10000" >/dev/null
  ########## I prefer no disk ID
  sysrc -f "${mnt}/boot/loader.conf" "kern.geom.label.disk_ident.enable=0" \
    >/dev/null
  sysrc -f "${mnt}/boot/loader.conf" "kern.geom.label.gpt.enable=0" >/dev/null
  ########## But I allow UUID
  sysrc -f "${mnt}/boot/loader.conf" "kern.geom.label.gptid.enable=1" \
    >/dev/null
  ########## Kernel max
  sysrc -f "${mnt}/boot/loader.conf" "kern.maxfiles=65530" >/dev/null
  ########## loader_logo should stop logo from showing, appears to be BROKEN
  sysrc -f "${mnt}/boot/loader.conf" loader_logo="none" >/dev/null
  sysrc -f "${mnt}/boot/loader.conf" nullfs_load="YES" >/dev/null
  ########## tmpfs_load for mfsroot /usr
  sysrc -f "${mnt}/boot/loader.conf" tmpfs_load="YES" >/dev/null
  ########## virtual if using emulators/virtio-kmod
  echo "# if_vtnet_load=\"YES\"" >>"${mnt}/boot/loader.conf"
  echo "# virtio_load=\"YES\"" >>"${mnt}/boot/loader.conf"
  echo "# virtio_pci_load=\"YES\"" >>"${mnt}/boot/loader.conf"
  echo "# virtio_blk_load=\"YES\"" >>"${mnt}/boot/loader.conf"
  echo "# virtio_balloon_load=\"YES\"" >>"${mnt}/boot/loader.conf"

  ########## Set some rc.conf options
  sysrc -f "${mnt}/etc/rc.conf.d/abi" linux_enable="YES" >/dev/null
  sysrc -f "${mnt}/etc/rc.conf.d/auditd" auditd_enable="YES" >/dev/null
  sysrc -f "${mnt}/etc/rc.conf.d/ezjail" ezjail_enable="YES" >/dev/null
  sysrc -f "${mnt}/etc/rc.conf.d/ftp-proxy" ftpproxy_enable="YES" >/dev/null
  sysrc -f "${mnt}/etc/rc.conf.d/ntpdate" ntpdate_enable="YES" >/dev/null
  sysrc -f "${mnt}/etc/rc.conf.d/ntpdate" ntpdate_hosts="$ntpdate_hosts" \
    >/dev/null
  sysrc -f "${mnt}/etc/rc.conf.d/openntpd" openntpd_enable="YES" >/dev/null
  sysrc -f "${mnt}/etc/rc.conf.d/pf" pf_enable="YES" >/dev/null
  sysrc -f "${mnt}/etc/rc.conf.d/pf" pf_rules="/etc/pf/pf.conf" >/dev/null
  sysrc -f "${mnt}/etc/rc.conf.d/pflog" pflog_enable="YES" >/dev/null
  sysrc -f "${mnt}/etc/rc.conf.d/pflog" pflog_logfile="/var/log/pflog" >/dev/null
  sysrc -f "${mnt}/etc/rc.conf.d/random" entropy_file="/var/db/entropy-file" >/dev/null
  echo "# sendmail_enable=\"NO\"" >>"${mnt}/etc/rc.conf.d/sendmail"
  echo "# sendmail_submit_enable=\"NO\"" >>"${mnt}/etc/rc.conf.d/sendmail"
  echo "# sendmail_outbound_enable=\"NO\"" >>"${mnt}/etc/rc.conf.d/sendmail"
  echo "# sendmail_msp_queue_enable=\"NO\"" >>"${mnt}/etc/rc.conf.d/sendmail"
  sysrc -f "${mnt}/etc/rc.conf.d/sshd" sshd_enable="YES" >/dev/null
  sysrc -f "${mnt}/etc/rc.conf.d/sshd" sshd_rsa1_enable="NO" >/dev/null
  sysrc -f "${mnt}/etc/rc.conf.d/syslogd" syslogd_flags="-s -b127.0.0.1" >/dev/null
  sysrc -f "${mnt}/etc/rc.conf.local" zfs_enable="YES" >/dev/null
  ########## Set SSH options
  grep '^ChallengeResponseAuthentication no' "${mnt}/etc/ssh/sshd_config" || \
    echo ChallengeResponseAuthentication no >>"${mnt}/etc/ssh/sshd_config"
  grep '^PermitRootLogin yes' "${mnt}/etc/ssh/sshd_config" || \
    echo PermitRootLogin yes >>"${mnt}/etc/ssh/sshd_config"
  grep '^UseDNS no' "${mnt}/etc/ssh/sshd_config" || \
    echo UseDNS no >>"${mnt}/etc/ssh/sshd_config"
  grep '^ClientAliveInterval 5' "${mnt}/etc/ssh/sshd_config" || \
    echo ClientAliveInterval 5 >>"${mnt}/etc/ssh/sshd_config"
}

freebsdconfigglobalmfsroot() {
}

freebsdconfiglocal() {
  ########## .local specific to this machine
  sysrc -f "${mnt}/boot/loader.conf.local" aesni_load="YES" >/dev/null
  sysrc -f "${mnt}/boot/loader.conf.local" ahci_load="YES" >/dev/null
  sysrc -f "${mnt}/boot/loader.conf.local" aio_load="YES" >/dev/null
  sysrc -f "${mnt}/boot/loader.conf.local" geom_eli_load="YES" >/dev/null
  sysrc -f "${mnt}/boot/loader.conf.local" geom_label_load="YES" >/dev/null
  sysrc -f "${mnt}/boot/loader.conf.local" geom_mirror_load="YES" >/dev/null
  ########## hw.bge.allow_asf for my HP server to stop network disconnect
  sysrc -f "${mnt}/boot/loader.conf.local" "hw.bge.allow_asf=0" >/dev/null
  sysrc -f "${mnt}/boot/loader.conf.local" if_lagg_load="YES" >/dev/null
  sysrc -f "${mnt}/boot/loader.conf.local" "kern.maxswzone=512M" >/dev/null
  ########## vfs.zfs.arc_max limit arc usage on low RAM systems
  sysrc -f "${mnt}/boot/loader.conf.local" "vfs.zfs.arc_max=256M" >/dev/null
  sysrc -f "${mnt}/boot/loader.conf.local" zfs_load="YES" >/dev/null
  ########## network interfaces
  ifconfig -l | tr ' ' '\n' | \
awk '$1 !~ /lo[0-9]/ && \
$1 !~ /enc[0-9]/ && \
$1 !~ /fwe[0-9]/ && \
$1 !~ /fwip[0-9]/ && \
$1 !~ /gif[0-9]/ && \
$1 !~ /ipfw[0-9]/ && \
$1 !~ /pflog[0-9]/ && \
$1 !~ /plip[0-9]/ && \
$1 !~ /stf[0-9]/ && \
$1 !~ /lagg[0-9]/ {print $1}' | \
  while read line ; do
      grep "ifconfig_${line}" ${mnt}/etc/rc.conf.d/network \
        >/dev/null 2>&1 || \
        echo "# ifconfig_${line}=\"up\"" >>${mnt}/etc/rc.conf.d/network
      grep "ifconfig_${line}" ${mnt}/etc/rc.conf.d/network \
        >/dev/null 2>&1 || \
        echo "# ifconfig_${line}=\"up\"" >>${mnt}/etc/rc.conf.d/network
  done
  ########## Set lagg as optional comments
  echo '########## To enable Link Aggregation: BEGIN' \
    >>${mnt}/etc/rc.conf.d/network
  nics=`ifconfig -l | tr ' ' '\n' | \
awk '$1 !~ /lo[0-9]/ && \
$1 !~ /enc[0-9]/ && \
$1 !~ /fwe[0-9]/ && \
$1 !~ /fwip[0-9]/ && \
$1 !~ /gif[0-9]/ && \
$1 !~ /ipfw[0-9]/ && \
$1 !~ /pflog[0-9]/ && \
$1 !~ /plip[0-9]/ && \
$1 !~ /stf[0-9]/ && \
$1 !~ /lagg[0-9]/ {print "laggport "$1}' | tr '\n' ' '`
  echo "# cloned_interfaces=\"lagg0\"" >>${mnt}/etc/rc.conf.d/network
  echo "# ifconfig_lagg0=\"DHCP laggproto loadbalance $nics\"" \
    >>${mnt}/etc/rc.conf.d/network
  echo "# ifconfig_lagg0=\"inet 192.168.0.2/24 laggproto loadbalance $nics\"" \
    >>${mnt}/etc/rc.conf.d/network
  echo '########## To enable Link Aggregation: END' \
    >>${mnt}/etc/rc.conf.d/network
}

freebsdconfiglocalmfsroot() {
  ########## need this or zfs won't load
  sysrc -f "${mnt}/etc/rc.conf.local" zfs_enable="YES" >/dev/null
  ########## mfs_ settings in loader.conf
  sysrc -f "${mnt}/boot/loader.conf.local" mfs_load="YES" >/dev/null
  sysrc -f "${mnt}/boot/loader.conf.local" mfs_type="mfs_root" >/dev/null
  sysrc -f "${mnt}/boot/loader.conf.local" mfs_name="/$mfsfile" >/dev/null
  sysrc -f "${mnt}/boot/loader.conf.local" "vfs.root.mountfrom=ufs:/dev/md0" \
    >/dev/null
  ########## optional set netwait_
  echo "# netwait_enable=\"YES\"" \
    >>${mnt}/etc/rc.conf.d/netwait
  echo "# netwait_ip=\"`netstat -nr | grep default | awk '{print $2}'`\"" \
    >>${mnt}/etc/rc.conf.d/netwait
  ########## set defaultrouter
  echo "# defaultrouter=\"`netstat -nr | grep default | awk '{print $2}'`\"" \
    >>${mnt}/etc/rc.conf.d/routing
  ########## optional set packages to list we can pkg install -f -y ____
  echo "# packages=\"\"" \
    >>${mnt}/boot/loader.conf.local
  ########## optional set zpools to import
  echo "# zpool_import=\"\"" \
    >>${mnt}/boot/loader.conf.local
  ########## optional set mdinit_shell
  echo "# mdinit_shell=\"YES\"" \
    >>${mnt}/boot/loader.conf.local
}

######################################################################
# Function wrapper so we can toggle between using bsdinstall and custom
######################################################################

makepoolwith() {
  ########## $1 is method
  if [ "$1" = "zfsboot" ]; then
    ########## No ZFSBOOT_GNOP_4K_FORCE_ALIGN because if we use it,
    ########## we can't add mirror later
    ZFSBOOT_DISKS="$disks" \
    ZFSBOOT_VDEV_TYPE=$raidtype \
    ZFSBOOT_POOL_NAME=$rpool \
    ZFSBOOT_POOL_SIZE=$zsize \
    ZFSBOOT_BEROOT_NAME=$bename \
    ZFSBOOT_BOOTFS_NAME=$bfsname \
    ZFSBOOT_GELI_ENCRYPTION=1 \
    ZFSBOOT_BOOT_POOL_NAME=$bpool \
    ZFSBOOT_BOOT_POOL_SIZE=$bsize \
    ZFSBOOT_SWAP_SIZE=$ssize \
    ZFSBOOT_SWAP_ENCRYPTION=1 \
    ZFSBOOT_GELI_KEY_FILE=$keyfile \
    nonInteractive=0 \
    bsdinstall zfsboot || exiterror $?
  elif [ "$1" = "zfsinstall" ]; then
    ZFSBOOT_DATASETS="
        # DATASET       OPTIONS (comma or space separated; or both)

        # Boot Environment [BE] root and default boot dataset
        /$bename               mountpoint=none
        /$bename/$bfsname      mountpoint=/

        # Compress /tmp, allow exec but not setuid
        /tmp            mountpoint=/tmp,exec=on,setuid=off

        # Don't mount /usr so that 'base' files go to the BEROOT
        /usr            mountpoint=/usr,canmount=off

        # Home directories separated so they are common to all BEs
        /usr/home       # NB: /home is a symlink to /usr/home

        # Ports tree
        /usr/ports      setuid=off

        # Source tree (compressed)
        /usr/src

        # Create /var and friends
        /var            mountpoint=/var,canmount=off
        /var/crash      exec=off,setuid=off
        /var/log        exec=off,setuid=off
        /var/mail       atime=on
        /var/tmp        setuid=off
" # END-QUOTE
##########
# Disk partitioning
# modified from https://github.com/mmatuska/mfsbsd
##########
    install -d -m 700 ${bsdinstalltmp}
    install -d -m 700 ${bsdinstalletc}
    umount ${bsdinstalltmp} >/dev/null 2>&1
    mount -t tmpfs tmpfs ${bsdinstalltmp}
    keyfiletmp=${bsdinstalltmp}/encryption.key
    cachetmp=${bsdinstalltmp}/zpool.cache
    cachereal=/boot/zfs/zpool.cache
    cacheoptions="-o cachefile=${cachetmp}"
    if [ ! -e ${keyfiletmp} ]; then
      dd if=/dev/random of=${keyfiletmp} bs=4096 count=1
    fi
    for DEV in $disks ; do
      ########## GPT create
      echo -n "Creating GUID partitions on $DEV ..."
      if ! gpart create -s GPT "/dev/$DEV" >/dev/null ; then
        echo " error at create"
        exiterror 1
      fi
      sync
      if ! echo "a 1" | fdisk -f - "$DEV" >/dev/null 2>&1 ; then
        echo " error at fdisk"
        exiterror 1
      fi
      ########## freebsd-boot for bootcode
      if ! gpart add -t freebsd-boot $align4k -s 512K "$DEV" >/dev/null ; then
        echo " error at freebsd-boot"
        exiterror 1
      fi
      ########## partition for /boot zpool
      if ! gpart add -t freebsd-zfs $align4k -s "${bsize}b" "${DEV}" \
        >/dev/null ; then
        echo " error at bpool"
        exiterror 1
      fi
      gptidboot=`glabel list ${DEV}${bootpart} | grep Name | head -1 | \
        awk '{print $NF}'`
      dd if=/dev/zero of="/dev/label/$gptidboot" bs=512 count=560 \
        >/dev/null 2>&1
      zpool labelclear -f "/dev/label/$gptidboot" >/dev/null 2>&1
      BPARTS="$BPARTS $gptidboot"
      ########## partition for swap
      if [ -n "$ssize" ]; then
        if ! gpart add -t freebsd-swap $align4k -s "${ssize}b" "${DEV}" \
          >/dev/null ; then
          echo " error at swap"
          exiterror 1
        fi
        gptidswap=`glabel list ${DEV}${swappart} | grep Name | head -1 | \
          awk '{print $NF}'`
        dd if=/dev/zero of="/dev/label/$gptidswap" bs=512 count=560 \
          >/dev/null 2>&1
        zpool labelclear -f "/dev/label/$gptidswap" >/dev/null 2>&1
        echo "/dev/$gptidswap.eli  none  swap  sw  0  0" \
          >>${bsdinstalletc}/fstab
      fi
      ########## partition for main root pool
      if [ -n "$zsize" ]; then
        ZSIZE="-s ${zsize}b"
      fi
      if ! gpart add -t freebsd-zfs $align4k $ZSIZE "${DEV}" >/dev/null ; then
        echo " error at zsize"
        exiterror 1
      fi
      gptidtarget=`glabel list ${DEV}${targetpart} | grep Name | head -1 | \
        awk '{print $NF}'`
      safegptidtarget=`echo $gptidtarget | sed 's#/#_#'`
      dd if=/dev/zero of="/dev/label/$gptidtarget" bs=512 count=560 \
        >/dev/null 2>&1
      zpool labelclear -f "/dev/label/$gptidtarget" >/dev/null 2>&1
      geli init -b -B "${bsdinstalltmp}/${safegptidtarget}.eli" \
        -P -K "$keyfiletmp" -e AES-XTS -l 256 -s 4096 "$gptidtarget"
      geli attach -p -k "$keyfiletmp" "$gptidtarget"
      TPARTS="$TPARTS $gptidtarget.eli"
      sysrc -f ${bsdinstalltmp}/loader.conf.geli \
        "geli_${safegptidtarget}_keyfile0_load=YES"
      sysrc -f ${bsdinstalltmp}/loader.conf.geli \
        "geli_${safegptidtarget}_keyfile0_type=${gptidtarget}:geli_keyfile0"
      sysrc -f ${bsdinstalltmp}/loader.conf.geli \
        "geli_${safegptidtarget}_keyfile0_name=${keyfile}"
      echo " done"
      ########## Bootcode
      echo -n "Configuring ZFS bootcode on $DEV ..."
      if ! gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 "$DEV" \
        >/dev/null ; then
        echo " error at bootcode"
        exiterror 1
      fi
      echo " done"
    done
    ########## create main root pool
    [ "$raidtype" != "stripe" ] && TRAID=$raidtype
    echo -n "Creating ZFS pool $rpool on $TPARTS ..."
    if ! zpool create -f -m none ${cacheoptions} \
      -O compress=lz4 -O atime=off -R ${mnt} \
      $rpool $TRAID $TPARTS >/dev/null 2>&1 ; then
      echo " error"
      exiterror 1
    fi
    echo " done"
    ########## create datasets
    echo -n "Creating ZFS datasets ..."
    echo "$ZFSBOOT_DATASETS" | while read dataset options; do
      case "$dataset" in "#"*|"") continue; esac
      options="${options%%#*}"
      oldoptions=
      while [ "$oldoptions" != "$options" ]; do
        oldoptions="$options"
        newoptions=`echo $options | sed 's/  / /g'`
        options="$newoptions"
      done
      newoptions=`echo $options | sed 's/[ ,]/ -o /g'`
      options="$newoptions"
      if ! zfs create ${options:+-o $options} "${rpool}${dataset}" \
        >/dev/null 2>&1 ; then
        echo " error"
        exiterror 1
      fi
      echo -n " $dataset"
    done
    echo " done"
    ########## set bootfs, unsure if still needed
    echo -n "Setting bootfs for $rpool to ${rpool}/${bename}/${bfsname} ..."
    if ! zpool set bootfs="${rpool}/${bename}/${bfsname}" "$rpool" \
      >/dev/null 2>&1 ; then
      echo " error"
      exiterror 1
    fi
    echo " done"
    ########## create boot pool
    echo -n "Creating bootable ZFS pool $bpool on $BPARTS ..."
    count=$( echo "$disks" | wc -w | awk '{ print $1 }' )
    [ "$count" -gt "1" ] && BRAID=mirror
    if ! zpool create -f ${cacheoptions} -R ${mnt} \
      $bpool $BRAID $BPARTS >/dev/null 2>&1 ; then
      echo " error"
      exiterror 1
    fi
    echo " done"
    ########## link boot pool
    install -d -m 755 ${mnt}/${bpool}/boot
    ln -sf ${bpool}/boot ${mnt}/boot
    ########## copy header backups
    chmod 600 ${bsdinstalltmp}/*.eli
    cp -a ${bsdinstalltmp}/*.eli ${mnt}/boot/
    ########## cachefile
    echo -n "Copying zpool.cache ..."
    sysrc -f ${bsdinstalltmp}/loader.conf.zfs \
      zpool_cache_load="YES"
		sysrc -f ${bsdinstalltmp}/loader.conf.zfs \
      zpool_cache_type="${cachereal}"
		sysrc -f ${bsdinstalltmp}/loader.conf.zfs \
      zpool_cache_name="${cachereal}"
    if ! zpool export -f $bpool >/dev/null 2>&1 ; then
      echo " error exporting $bpool"
      exiterror 1
    fi
    if ! zpool export -f $rpool >/dev/null 2>&1 ; then
      echo " error exporting $rpool"
      exiterror 1
    fi
    if ! zpool import -f ${cacheoptions} -R ${mnt} $rpool \
      >/dev/null 2>&1 ; then
      echo " error importing $rpool"
      exiterror 1
    fi
    if ! zpool import -f ${cacheoptions} -R ${mnt} $bpool \
      >/dev/null 2>&1 ; then
      echo " error importing $bpool"
      exiterror 1
    fi
    install -d 755 ${mnt}/boot/zfs
    if ! cp ${cachetmp} "${mnt}${cachereal}" >/dev/null 2>&1 ; then
      echo " error copying zpool.cache"
      exiterror 1
    fi
    echo " done"
    ########## keyfile
    echo -n "Copying keyfile ..."
    if ! cp ${keyfiletmp} "${mnt}${keyfile}" >/dev/null 2>&1 ; then
      echo " error copying keyfile"
      exiterror 1
    fi
    echo " done"
  fi
}

######################################################################
######################################################################
# End of functions
######################################################################
######################################################################

######################################################################
# Options parsing
# modified from https://github.com/mmatuska/mfsbsd
######################################################################

if [ $# -eq 0 ]; then
  usage ; exiterror 1
fi

while getopts b:d:e:p:r:s:M:z:cCiulxmfnvh o; do
  case "$o" in
    b) bsize="$OPTARG" ;;
    d) disks="$disks ${OPTARG##/dev/}" ;;
    e) edisk="$OPTARG" ; ADDTOPOOL=1 ;;
    p) rpool="$OPTARG" ; bpool="boot${rpool}" ;;
    r) raidtype="$OPTARG" ;;
    s) ssize="$OPTARG" ;;
    M) mnt="$OPTARG" ;;
    z) zsize="$OPTARG" ;;
    c) freebsdconfigglobal ; exit ;;
    C) freebsdconfigglobal ; freebsdconfiglocal ; exit ;;
    i) DATAINIT=1 ; DATAAUTO=1 ;;
    u) DATAUNLOCK=1 ;;
    l) DATALOCK=1 ;;
    x) unset DATAAUTO ;;
    m) MAKEMFSROOT=1 ;;
    f) NEWMFSROOT=1 ;;
    n) PROMPTCHANGEPASSWD=n ;;
    v) echo $SCRIPTVERSION ; exiterror 1 ;;
    h) usage ; exiterror 1 ;;
    [?]) usage ; exiterror 1 ;;
  esac
done

if [ "$DATAINIT" -a "$DATALOCK" ]; then
  echo "Only pass -i or -l, not both."
  exiterror 1
elif [ "$DATALOCK" -a "$DATAUNLOCK" ]; then
  echo "Only pass -l or -u, not both."
  exiterror 1
elif [ "$DATAUNLOCK" -a "$DATAINIT" ]; then
  echo "Only pass -u or -i, not both."
  exiterror 1
elif [ "$DATAINIT" -a "$NEWMFSROOT" ]; then
  echo "Only pass -i or -M, not both."
  exiterror 1
elif [ "$DATALOCK" -a "$NEWMFSROOT" ]; then
  echo "Only pass -l or -M, not both."
  exiterror 1
elif [ "$DATAUNLOCK" -a "$NEWMFSROOT" ]; then
  echo "Only pass -u or -M, not both."
  exiterror 1
fi

########## if not set, set rpool and mnt
if [ "$DATAINIT" -o "$DATALOCK" -o "$DATAUNLOCK" ]; then
: ${rpool:=tank}
: ${mnt:=/z}
else
: ${rpool:=pool}
: ${mnt:=/mnt}
fi

########## backup mfsroot
mfspath=${mnt}/${bpool}/$mfsfile
if [ "$NEWMFSROOT" = "1" ]; then
  mfspath=/boot/../${mfsfile}
  if [ -e ${mfspath} ]; then
    cp -a ${mfspath} ${mfspath}_old
  fi
fi

########## set, partitions
bootpart=p2
swappart=p3
targetpart=p3
[ -n "$ssize" ] && targetpart=p4

######################################################################
# Disk parsing for testing raid type
# modified from https://github.com/mmatuska/mfsbsd
######################################################################

if [ -z "$ADDTOPOOL" -o "$ADDTOPOOL" = "0" ] && [ -z "$DATAUNLOCK" ] && \
  [ -z "$NEWMFSROOT" ]; then
  count=$( echo "$disks" | wc -w | awk '{ print $1 }' )
  if [ "$count" -lt "3" -a "$raidtype" = "raidz" ]; then
    echo "ERROR: raidz needs at least three devices (-d switch)" ; exiterror 1
  elif [ "$count" -lt "4" -a "$raidtype" = "raidz2" ]; then
    echo "ERROR: raidz2 needs at least four devices (-d switch)" ; exiterror 1
  elif [ "$count" -lt "5" -a "$raidtype" = "raidz3" ]; then
    echo "ERROR: raidz3 needs at least five devices (-d switch)" ; exiterror 1
  elif [ "$count" = "1" -a "$raidtype" = "mirror" ]; then
    echo "ERROR: mirror needs at least two devices (-d switch)" ; exiterror 1
  elif [ "$count" = "2" -a "$raidtype" != "mirror" ]; then
    echo "NOTICE: two drives selected, automatically choosing mirror mode"
    raidtype="mirror"
  elif [ "$count" -gt "2" -a "$raidtype" != "mirror" -a \
    "$raidtype" != "raidz" -a "$raidtype" != "raidz2" -a \
    "$raidtype" != "raidz3" ]; then
    echo \
    "ERROR: please choose raid mode with -r (mirror or raidz{1,2,3})"
    exiterror 1
  fi
fi

######################################################################
# Disk detect
# modified from https://github.com/mmatuska/mfsbsd
######################################################################

if [ "$DATAINIT" -o "$DATALOCK" -o "$DATAUNLOCK" -o "$NEWMFSROOT" ]; then
  echo "NOTICE: Skipping device check."
else
  for DEV in $disks ; do
    if [ ! -c "/dev/$DEV" ]; then
      echo "ERROR: /dev/$DEV is not a block device"
      exiterror 1
    fi
    if gpart show "$DEV" >/dev/null 2>&1 ; then
      echo "ERROR: /dev/$DEV already contains a partition table."
      exiterror 1
    fi
  done
fi

######################################################################
# Quit if pools exist, but if ADDTOPOOL, quit if not exist
######################################################################

if [ -z "$DATALOCK" ] && [ -z "$DATAUNLOCK" ] && \
  [ -z "$ADDTOPOOL" -o "$ADDTOPOOL" = "0" ] && \
  [ -z "$NEWMFSROOT" ]; then
  if zpool status $rpool >/dev/null 2>&1 ; then
    echo "ERROR: A pool named $rpool already exists."
    exiterror 1
  fi
  if zpool status $bpool >/dev/null 2>&1 ; then
    echo "ERROR: A pool named $bpool already exists."
    exiterror 1
  fi
elif [ "$ADDTOPOOL" = "1" -o -n "$DATALOCK" ]; then
  if ! zpool status $rpool >/dev/null 2>&1 ; then
    echo "ERROR: A pool named $rpool doesn't exists."
    exiterror 1
  fi
  if [ -z "$DATALOCK" -a -z "$DATAINIT" ]; then
    if ! zpool status $bpool >/dev/null 2>&1 ; then
      echo "ERROR: A pool named $bpool doesn't exists."
      exiterror 1
    fi
  fi
fi

######################################################################
# DATAINIT
######################################################################
if [ "$DATAINIT" ]; then
  if [ "$DATAAUTO" ]; then
    echo -n "Creating data partitions ..."
    for disk in $disks; do
      PARTCREATED=0
      for GSIZE in $datasizes ; do
        while [ "$PARTCREATED" = "0" ]; do
          if [ "$PARTCREATED" != "1" ]; then
            if /sbin/gpart add -i 5 -t freebsd-zfs $align4k -s ${GSIZE}G \
              ${disk} >/dev/null 2>&1 ; then
              echo " success adding partition sized ${GSIZE}G at $disk"
              PARTCREATED=1
              gptidtarget=`glabel list ${disk}p5 | grep Name | head -1 | \
                awk '{print $NF}'`
              dd if=/dev/zero of="/dev/$gptidtarget" bs=512 count=560 \
                >/dev/null 2>&1
              zpool labelclear -f "/dev/$gptidtarget" >/dev/null 2>&1
              GPARTS="$GPARTS ${disk}p5"
            else
              ########## we should actually use the next datasizes,
              ########## but for now we'll decrement by 1
              GSIZE=$(( GSIZE - 1 ))
            fi
          fi
          if [ $GSIZE -lt 1 ]; then
            PARTCREATED=2
            echo " error adding partition at $disk"
          fi
        done
      done
      [ "$PARTCREATED" != "1" ] && exiterror 1
    done
    disks="$GPARTS"
  fi
  if [ ! -e ${datacryptkey} ]; then
    stty -echo
    printf "Data GELI Partition Key:"
    read PASSWORD
    stty echo
    printf "\n"
    echo -n "Encrypting Password, "
    echo $PASSWORD | crypt >${datacryptkey}
    unset PASSWORD
    [ -e ${mnt}/boot ] && cp -a ${datacryptkey} ${mnt}${datacryptkey}
  fi
  cryptdecode
  if [ ! -e $TMPFILE ]; then
    echo "ERROR: Can't cryptdecode."
    exiterror 1
  fi
  echo -n "Initializing data partitions ..."
  for disk in $disks; do
    echo -n " $disk"
    gptidtarget=`glabel list $disk | grep Name | head -1 | \
      awk '{print $NF}'`
    safegptidtarget=`echo $gptidtarget | sed 's#/#_#'`
    if ! geli init -b -B /boot/${safegptidtarget}.eli \
      -e AES-XTS -P -K $TMPFILE -l 256 -s 4096 ${gptidtarget} \
      >/dev/null 2>&1 ; then
      echo " error"
      exiterror 1
    fi
    [ -e ${mnt}/boot ] && cp -a /boot/${safegptidtarget}.eli \
      ${mnt}/boot/${safegptidtarget}.eli
    if ! geli attach -p -k $TMPFILE ${gptidtarget} >/dev/null 2>&1 ; then
      echo " error"
      exiterror 1
    fi
    vdevs="$vdevs ${gptidtarget}.eli"
  done
  rm $TMPFILE
  umount $crypttmp
  echo " done"
  if [ "$ADDTOPOOL" = "1" ]; then
    rpoolrealdisk=`zpool status $rpoolreal | grep -v state | \
      grep ONLINE | tail -1 | awk '{print $1}'`
    echo -n "Attaching pool $rpool ..."
    if ! zpool attach ${rpool} \
      ${rpoolrealdisk} ${vdevs} >/dev/null 2>&1 ; then
      echo " error"
      exiterror 1
    fi
    echo " done"
  else
    echo -n "Creating pool $rpool ..."
    [ "$raidtype" != "stripe" ] && TRAID=$raidtype
    if ! zpool create -O compress=lz4 -O atime=off ${rpool} \
      ${TRAID} ${vdevs} >/dev/null 2>&1 ; then
      echo " error"
      exiterror 1
    fi
    echo " done"
  fi
######################################################################
# DATALOCK
######################################################################
elif [ "$DATALOCK" ]; then
  echo -n "Exporting pool ${rpool} ..."
  disks=`zpool status ${rpool} | grep 'eli *ONLINE' | awk '{print $1}' | \
    tr '\n' ' '`
  if ! zpool export -f ${rpool} >/dev/null 2>&1 ; then
    echo " error"
    exiterror 1
  fi
  echo " done"
  sync
  echo -n "Detaching disks ..."
  for disk in $disks; do
    if [ -e /dev/${disk} ]; then
      echo -n " $disk"
      if ! geli detach ${disk} >/dev/null 2>&1 ; then
        sleep 1
        if [ -e /dev/${disk} ]; then
          echo " error"
        fi
      fi
    fi
  done
  echo " done"
######################################################################
# DATAUNLOCK
######################################################################
elif [ "$DATAUNLOCK" ]; then
  cryptdecode
  if [ ! -e $TMPFILE ]; then
    echo "ERROR: Can't cryptdecode."
    exiterror 1
  fi
  echo -n "Attaching disks ..."
  for disk in $disks; do
    gptidtarget=`glabel list $disk | grep Name | head -1 | \
      awk '{print $NF}'`
    safegptidtarget=`echo $gptidtarget | sed 's#/#_#'`
    if [ ! -e /dev/${gptidtarget}.eli ]; then
      echo -n " $disk"
      if ! geli attach -j $TMPFILE ${gptidtarget} \
        >/dev/null 2>&1 ; then
        echo " error"
        exiterror 1
      fi
    fi
  done
  rm $TMPFILE
  umount $crypttmp
  echo " done"
  echo -n "Importing pool ${rpool} ..."
  if ! zpool import ${rpool} >/dev/null 2>&1 ; then
    echo " error"
    exiterror 1
  fi
  echo " done"
fi

######################################################################
# exit if DATA
######################################################################

if [ "$DATAINIT" -o "$DATALOCK" -o "$DATAUNLOCK" ]; then
  exiterror 0
fi

######################################################################
# Bootstrap pkgng early so user doesn't have to wait
######################################################################

if [ ! -f /usr/local/sbin/pkg-static ]; then
  pkg bootstrap
fi

######################################################################
# How to create a b64 patch
######################################################################
# diff -u zfsboot /usr/libexec/bsdinstall/zfsboot | xz | b64encode -

######################################################################
# Patch zfsboot for passwordless (-P,-p) geli
######################################################################

zfsbootpath=/usr/libexec/bsdinstall/zfsboot
chmod 755 $zfsbootpath
b64decode -o /dev/stdout <<EOF | xz -d | patch -N -l $zfsbootpath
begin-base64 644 -
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
====
EOF
chmod 555 $zfsbootpath

######################################################################
# load geli and remove past bsdinstall temporary files
######################################################################

geli load
rm -r /tmp/bsdinstall*

######################################################################
# Perform creation of zfsboot using zfsboot or zfsinstall
######################################################################

if [ -z "$NEWMFSROOT" ]; then

  if [ "$ADDTOPOOL" = "1" ]; then
    bpoolreal=$bpool
    bpooltmp=tmpbpool
    bpool=$bpooltmp
    rpoolreal=$rpool
    rpooltmp=tmprpool
    rpool=$rpooltmp
  fi
  ########## makepoolwith zfsboot or zfsinstall
  makepoolwith zfsinstall

  ######################################################################
  # Do ADDTOPOOL stuff
  ######################################################################

  if [ "$ADDTOPOOL" = "1" ]; then
  ########## get existing disk
  bpoolrealdisk=`zpool status $bpoolreal | grep -v state | \
  grep ONLINE | tail -1 | awk '{print $1}'`
  rpoolrealdisk=`zpool status $rpoolreal | grep -v state | \
  grep ONLINE | tail -1 | awk '{print $1}'`
  ########## get new disk
  bpooltmpdisk=`zpool status $bpooltmp | grep -v state | \
  grep ONLINE | tail -1 | awk '{print $1}'`
  rpooltmpdisk=`zpool status $rpooltmp | grep -v state | \
  grep ONLINE | tail -1 | awk '{print $1}'`
  ########## destroy pool
  zpool destroy -f $bpooltmp
  zpool destroy -f $rpooltmp
  ########## attach bpool
  echo "Trying: zpool attach -f $bpoolreal $bpoolrealdisk $bpooltmpdisk"
  zpool attach -f $bpoolreal $bpoolrealdisk $bpooltmpdisk || exiterror 1
  ########## attach rpool
  geli detach $rpooltmpdisk
  safefilename=` echo $rpooltmpdisk | sed 's#/#_#'`
  if [ -f /${bpoolreal}${keyfile} ]; then
    echo "Trying: geli init"
    geli init -b \
      -B "/${bpoolreal}/boot/${safefilename}" -e AES-XTS -P \
      -K "/${bpoolreal}${keyfile}" \
      -l 256 -s 4096 ${rpooltmpdisk%.eli} || exiterror 1
    echo "Trying: geli attach"
    geli attach -p -k "/${bpoolreal}${keyfile}" \
      ${rpooltmpdisk%.eli} || exiterror 1
  elif [ -f ${mnt}/${bpoolreal}${keyfile} ]; then
    echo "Trying: geli init"
    geli init -b \
      -B "${mnt}/${bpoolreal}/boot/${safefilename}" -e AES-XTS -P \
      -K "${mnt}/${bpoolreal}${keyfile}" \
      -l 256 -s 4096 ${rpooltmpdisk%.eli} || exiterror 1
    echo "Trying: geli attach"
    geli attach -p -k "${mnt}/${bpoolreal}${keyfile}" \
      ${rpooltmpdisk%.eli} || exiterror 1
  fi
  echo "Trying: zpool attach -f $rpoolreal $rpoolrealdisk $rpooltmpdisk"
  zpool attach -f $rpoolreal $rpoolrealdisk $rpooltmpdisk || exiterror $?
  cat <<EOF
  Please wait for resilver to complete!
  You can see the status of the process with:
        zpool status
EOF
  fi

  ######################################################################
  # Copy the generated /boot/loader.conf and /etc/fstab
  ######################################################################

  if [ "$ADDTOPOOL" = "1" ]; then
    if [ ! -e ${mnt}/${bpoolreal}${keyfile} ]; then
      mnt=
    fi
  fi
  if [ "$ADDTOPOOL" = "1" -o "$MAKEMFSROOT" ]; then
    cat ${bsdinstalltmp}/loader.conf.* | \
      grep -v vfs.root.mountfrom | \
      grep -v aesni_load | \
      grep -v geom_eli_load | \
      grep -v zfs_load | \
      grep -v kern.geom.label.gptid.enable >>${mnt}/boot/loader.conf.local
  else
    cat ${bsdinstalltmp}/loader.conf.* | \
      grep -v aesni_load | \
      grep -v geom_eli_load | \
      grep -v zfs_load | \
      grep -v kern.geom.label.gptid.enable >>${mnt}/boot/loader.conf.local
    chmod 644 ${mnt}/boot/loader.conf.local
  fi
  umount ${bsdinstalltmp} >/dev/null 2>&1
  if [ -e ${bsdinstalletc}/fstab ]; then
    cat ${bsdinstalletc}/fstab >>${mnt}/boot/fstab.append
    chmod 644 ${mnt}/boot/fstab.append
  fi
  if [ "$ADDTOPOOL" = "1" ]; then
    exit
  fi

fi # end of if [ -z "$NEWMFSROOT" ]; then

######################################################################
# Check if local distribution exists, if so copy to mnt
######################################################################

########## this notation /boot/.. is in case /boot is a symlink (eg. mfsroot)
distdir=/boot/../${release}
if [ -z "$NEWMFSROOT" ]; then
  if [ ! -e $distdir/kernel.txz -o ! -e $distdir/base.txz ]; then
    distdir=${mnt}/boot/../${release}
  else
    echo -n "Copying $distdir to ${mnt}/boot/../${release}"
    install -d -m 755 ${mnt}/boot/../${release}
    tar -c -f - -C /boot/.. ${release} | tar -C ${mnt}/boot/.. -x -f - || \
      exiterror 1
    echo " done"
  fi
fi # end of if [ -z "$NEWMFSROOT" ]; then
install -d -m 755 $distdir

######################################################################
# Fetch distribution if no local copy exists
######################################################################

if [ ! -e $distdir/kernel.txz -o ! -e $distdir/base.txz ]; then
  DISTRIBUTIONS="kernel.txz base.txz lib32.txz" \
  BSDINSTALL_DISTDIR=$distdir \
  BSDINSTALL_DISTSITE="$distsite/`uname -m`/`uname -p`/${release}" \
  nonInteractive=0 \
  bsdinstall distfetch || exiterror $?
fi

######################################################################
# Create upgrade if $NEWMFSROOT
######################################################################

if [ "$NEWMFSROOT" = "1" ]; then
  zfs create -o mountpoint=${mnt} ${rpool}/upgrade
fi

######################################################################
# Create some extra datasets if mfsroot
# modified from /usr/libexec/bsdinstall/zfsboot
######################################################################

MFS_DATASETS="
        /etc            mountpoint=/etc,canmount=off
        /etc/mail       exec=off,setuid=off
        /etc/pf         exec=off,setuid=off
        /etc/rc.conf.d  exec=off,setuid=off
        /etc/ssh        exec=off,setuid=off

        /root           mountpoint=/root,canmount=off
        /root/.ssh      exec=off,setuid=off
        /root/bin       setuid=off

        /usr/local

        /var/at         exec=off,setuid=off
        /var/backups    exec=off,setuid=off
        /var/cache      exec=off,setuid=off
        /var/cron       exec=off,setuid=off
        /var/db         exec=off,setuid=off
        /var/run
        /var/spool      exec=off,setuid=off
" # END-QUOTE

if [ "$MAKEMFSROOT" ] && [ -z "$NEWMFSROOT" ]; then
  ########## create datasets
  echo -n "Creating ZFS datasets for MFS setup ..."
  echo "$MFS_DATASETS" | while read dataset options; do
    case "$dataset" in "#"*|"") continue; esac
    options="${options%%#*}"
    oldoptions=
    while [ "$oldoptions" != "$options" ]; do
      oldoptions="$options"
      newoptions=`echo $options | sed 's/  / /g'`
      options="$newoptions"
    done
    newoptions=`echo $options | sed 's/[ ,]/ -o /g'`
    options="$newoptions"
    if ! zfs create ${options:+-o $options} "${rpool}${dataset}" \
      >/dev/null 2>&1 ; then
      echo " error"
      exiterror 1
    fi
    echo -n " $dataset"
  done
  echo " done"
elif [ "$NEWMFSROOT" = "1" ]; then
  ORIGINAL_SET="
        /${bpool}
        /tmp
        /usr
        /var/crash
        /var/log
        /var/mail
        /var/tmp
"
  ########## create datasets
  echo -n "Creating TMPFS for MFS setup ..."
  echo "$ORIGINAL_SET" | while read dataset options; do
    case "$dataset" in "#"*|"") continue; esac
    install -d -m 755 "${mnt}${dataset}"
    if ! mount -t tmpfs tmpfs "${mnt}${dataset}" \
      >/dev/null 2>&1 ; then
      echo " error"
      exiterror 1
    fi
    echo -n " $dataset"
  done
  install -d -m 755 ${mnt}/${bpool}/boot
  ln -sf ${bpool}/boot ${mnt}/boot
  echo "$MFS_DATASETS" | while read dataset options; do
    case "$dataset" in "#"*|"") continue; esac
    if ! echo "$options" | grep "canmount=off" >/dev/null 2>&1 ; then
      install -d -m 755 "${mnt}${dataset}"
      if ! mount -t tmpfs tmpfs "${mnt}${dataset}" \
        >/dev/null 2>&1 ; then
        echo " error"
        exiterror 1
      fi
      echo -n " $dataset"
    fi
  done
  echo " done"
fi
chmod 700 ${mnt}/root/.ssh
chmod 700 ${mnt}/root/bin

######################################################################
# Extract ditribution
######################################################################

DISTRIBUTIONS="kernel.txz base.txz" \
BSDINSTALL_DISTDIR=$distdir \
BSDINSTALL_CHROOT=$mnt \
nonInteractive=0 \
bsdinstall distextract || exiterror $?

######################################################################
# Allow for update using freebsd-update
######################################################################

if [ "$NEWMFSROOT" = "1" ]; then
  echo "nameserver 8.8.8.8" >${mnt}/etc/resolv.conf
  chroot ${mnt} freebsd-update fetch
  chroot ${mnt} freebsd-update install
  cat <<EOF
Please connect another session and check that the system updated successfully:
        chroot $mnt freebsd-update fetch
        chroot $mnt freebsd-update install
EOF
  echo -n "Then here, press ENTER to continue "
  read CONTINUENOW
  rm ${mnt}/etc/resolv.conf
fi # end of if [ -z "$NEWMFSROOT" ]; then

######################################################################
# Copy pkg-static
######################################################################

if [ -f /usr/local/sbin/pkg-static ]; then
  install -m 700 -o root -g wheel /usr/local/sbin/pkg-static ${mnt}/sbin/pkg-static
fi

######################################################################
# Fetch some packages we can cache in /boot/packages
######################################################################

if [ -z "$NEWMFSROOT" ]; then

  install -d -m 755 ${mnt}/boot/packages
  if [ -d /boot/packages ]; then
    echo "Copying /boot/packages to ${mnt}/boot/packages"
    tar -c -f - -C /boot/ packages | tar -C ${mnt}/boot/ -x -f - || exiterror $?
  else
    if [ -f /usr/local/etc/pkg.conf ]; then
      cat /usr/local/etc/pkg.conf >/usr/local/etc/pkg.conf.bkp
    fi
    install -d -m 755 /usr/local/etc
    echo "PKG_CACHEDIR = \"${mnt}/boot/packages\";" >>/usr/local/etc/pkg.conf
    if [ -e $HOME/.cshpkglist ]; then
      PKGLIST="`cat $HOME/.cshpkglist | grep -v '^#' | tr ' ' '\n' | grep -v '^\$'`"
    else
      PKGLIST="
cmdwatch
ezjail
git expat p5-Authen-SASL p5-GSSAPI perl5 p5-Digest-HMAC
  p5-Net-SMTP-SSL p5-IO-Socket-SSL p5-Mozilla-CA p5-Net-SSLeay
  p5-Socket p5-IO-Socket-IP python27 libffi indexinfo gettext-runtime
  p5-Error curl ca_root_nss cvsps p5-MIME-Base64
gnupg1 indexinfo curl ca_root_nss gettext-runtime
iftop
nginx pcre
openntpd
openssl
pkg
rsync
tmux libevent2
ucarp
wget indexinfo libidn gettext-runtime
" # end of PKGLIST
    fi
    ########## Don't exiterror, because pkg-static segfault
    pkg-static fetch -y $PKGLIST
    if [ -f /usr/local/etc/pkg.conf.bkp ]; then
      cat /usr/local/etc/pkg.conf.bkp >/usr/local/etc/pkg.conf
      rm /usr/local/etc/pkg.conf.bkp
    else
      rm /usr/local/etc/pkg.conf
    fi
  fi

fi # end of if [ -z "$NEWMFSROOT" ]; then

######################################################################
# Set config
######################################################################

freebsdconfigglobal
freebsdconfiglocal

######################################################################
# Set ifconfig DHCP
######################################################################

ifconfig -l | tr ' ' '\n' | \
awk '$1 !~ /lo[0-9]/ && \
$1 !~ /enc[0-9]/ && \
$1 !~ /fwe[0-9]/ && \
$1 !~ /fwip[0-9]/ && \
$1 !~ /gif[0-9]/ && \
$1 !~ /ipfw[0-9]/ && \
$1 !~ /pflog[0-9]/ && \
$1 !~ /plip[0-9]/ && \
$1 !~ /stf[0-9]/ && \
$1 !~ /lagg[0-9]/ {print $1}' | \
while read line ; do
  sysrc -f "${mnt}/etc/rc.conf.d/network" ifconfig_${line}="DHCP"
done

######################################################################
# Change password of new system to blank
######################################################################

yes '' | chroot $mnt passwd

######################################################################
# Actually make the MFSROOT
######################################################################

if [ "$MAKEMFSROOT" -o "$NEWMFSROOT" ]; then
  echo "Creating mfsroot container at ${mfspath} with dd"
  dd if=/dev/zero of=${mfspath} bs=512 count=245760 || exiterror $?
  mdevice=`mdconfig -a -t vnode -f ${mfspath}`
  install -d -m 755 $mfsmnt
  echo "Making new fs on /dev/${mdevice}"
  newfs /dev/${mdevice} || exiterror $?
  echo "Mouting /dev/${mdevice} to $mfsmnt"
  mount /dev/${mdevice} $mfsmnt || exiterror $?
  ########## Copy everything except /usr
  echo "Copying ${mnt} to $mfsmnt"
  tar -c -f - \
    --exclude ./$bpool \
    --exclude ./${release} \
    --exclude ./etc/mail \
    --exclude ./etc/pf \
    --exclude ./etc/rc.conf.d \
    --exclude ./etc/ssh \
    --exclude ./usr \
    --exclude ./var/at \
    --exclude ./var/backups \
    --exclude ./var/cache \
    --exclude ./var/crash \
    --exclude ./var/cron \
    --exclude ./var/db \
    --exclude ./var/log \
    --exclude ./var/mail \
    --exclude ./var/run \
    --exclude ./var/spool \
    --exclude ./var/tmp \
    -C ${mnt} ./ | tar -C $mfsmnt -x -f - || exiterror $?
  ########## rc script for tmpfs /usr
  ########## modified from https://github.com/mmatuska/mfsbsd
  cat >$mfsmnt/etc/rc.d/mdinit <<EOF
#!/bin/sh
# \$Id\$
# PROVIDE: mdinit
# BEFORE: zfs FILESYSTEMS
# REQUIRE: mountcritlocal
# KEYWORD: FreeBSD
. /etc/rc.subr
name="mdinit"
start_cmd="mdinit_start"
stop_cmd=":"
mdinit_start()
{
  if [ -f /.usr.tar.xz ]; then
    /rescue/test -d /usr || /rescue/mkdir /usr
    /rescue/test -d /usr && /rescue/mount -t tmpfs tmpfs /usr
    /rescue/test -d /usr && /rescue/tar -x -C / -f /.usr.tar.xz
  elif [ -f /.usr.tar.bz2 ]; then
    /rescue/test -d /usr || /rescue/mkdir /usr
    /rescue/test -d /usr && /rescue/mount -t tmpfs tmpfs /usr
    /rescue/test -d /usr && /rescue/tar -x -C / -f /.usr.tar.bz2
  elif [ -f /.usr.tar.gz ]; then
    /rescue/test -d /usr || /rescue/mkdir /usr
    /rescue/test -d /usr && /rescue/mount -t tmpfs tmpfs /usr
    /rescue/test -d /usr && /rescue/tar -x -C / -f /.usr.tar.gz
  fi
  if [ ! -f /usr/bin/which ]; then
    echo "ERROR: in mdinit while extracting /usr, entering shell:"
    /rescue/sh
  fi
  if zfs list -H -o name,canmount,mountpoint | \
    awk '\$2 ~ /on/ {print}' | grep 'on[^/]*/\$' ; then
    echo "Disabling some zfs datasets that mount to /"
    DATASETS=\$(zfs list -H -o name,canmount,mountpoint | \
    awk '\$2 ~ /on/ {print}' | grep 'on[^/]*/\$' | awk '{print \$1}')
    for Z in \$DATASETS ; do
      echo zfs set canmount=off \$Z
      zfs set canmount=off \$Z
    done
  fi
  if /bin/kenv -q mdinit_shell | grep YES ; then
    echo "Found mdinit_shell, entering shell:"
    /rescue/sh
  fi
}
load_rc_config \$name
run_rc_command "\$1"
EOF
  chmod 555 $mfsmnt/etc/rc.d/mdinit
  ########## zpoolimport because we are in mfs and harder to persist
  cat >$mfsmnt/etc/rc.d/zpoolimport <<EOF
#!/bin/sh
# \$Id\$
# PROVIDE: zpoolimport
# BEFORE: hostname netif
# REQUIRE: mdinit FILESYSTEMS
# KEYWORD: FreeBSD
. /etc/rc.subr
name="zpoolimport"
start_cmd="zpoolimport_start"
stop_cmd=":"
zpoolimport_start()
{
  ########## import before trying /boot/*
  if /bin/kenv -q zpool_import 2>/dev/null ; then
    for i in \$( /bin/kenv -q zpool_import ) ; do
      /sbin/zpool import -f "\$i"
    done
  fi
  for f in fstab hosts periodic.conf resolv.conf sysctl.conf ; do
    suffix=.overwrite
    if [ -e /boot/\${f}\${suffix} ]; then
      cat /boot/\${f}\${suffix} >/etc/\${f}
    fi
    suffix=.append
    if [ -e /boot/\${f}\${suffix} ]; then
      cat /boot/\${f}\${suffix} >>/etc/\${f}
    fi
  done
  service sysctl start
}
load_rc_config \$name
run_rc_command "\$1"
EOF
  chmod 555 $mfsmnt/etc/rc.d/zpoolimport
  ########## packages because we are in mfs and harder to persist
  cat >$mfsmnt/etc/rc.d/packages <<EOF
#!/bin/sh
# \$Id\$
# PROVIDE: packages
# REQUIRE: FILESYSTEMS NETWORKING SERVERS DAEMON LOGIN dhclient
# KEYWORD: FreeBSD
. /etc/rc.subr
name="packages"
start_cmd="packages_start"
stop_cmd=":"
do_p_install()
{
  for P in \$( /bin/kenv -q packages ) ; do
    echo -n "Installing \$P..."
    ########## force pkg to re-add to create user/groups
    pkg-static install -f -y \$P >/var/log/packages.net.log 2>&1
    echo "done"
  done
  service ezjail start
  if ls /boot/packages/*.t?z >/dev/null 2>&1 ; then
    ########## force pkg to re-add to create user/groups
    pkg-static add -f \$( ls /boot/packages/*.t?z ) >/var/log/packages.local.log 2>&1
    service openntpd restart
  fi
}
packages_start()
{
  do_p_install &
}
load_rc_config \$name
run_rc_command "\$1"
EOF
  chmod 555 $mfsmnt/etc/rc.d/packages
  ########## Package /usr
  echo "Compressing ${mnt}/usr to $mfsmnt/.usr.tar.xz"
  tar -c -J -f $mfsmnt/.usr.tar.xz --exclude ${release} \
    --options xz:compression-level=9 -C ${mnt} usr || exiterror $?
  ########## if .csh*
  for i in /root/.csh* ; do
    echo -n "Copying ${i} to ${mfsmnt}/root/ ..."
    install -m 644 ${i} ${mfsmnt}/root/
    echo " done"
  done
  ########## Unmount
  echo "Unmounting /dev/${mdevice}"
  umount /dev/${mdevice} || exiterror $?
  mdconfig -d -u ${mdevice#md} || exiterror $?
  freebsdconfigglobalmfsroot
  freebsdconfiglocalmfsroot
fi

######################################################################
# Destroy upgrade if $NEWMFSROOT
######################################################################

if [ "$NEWMFSROOT" = "1" ]; then
  for k in 1 2 ; do
    for i in `mount | grep "tmpfs" | grep $mnt | awk '{print $3}'` ; do
      umount $i >/dev/null 2>&1
    done
  done
  zfs destroy ${rpool}/upgrade
fi

######################################################################
# If .ssh/authorized_keys exists, copy that
######################################################################

if [ -z "$NEWMFSROOT" ]; then
  if [ -e /root/.ssh/authorized_keys ]; then
    echo -n "Copying authorized_keys to ${mnt}/root/.ssh/authorized_keys ..."
    cp /root/.ssh/authorized_keys ${mnt}/root/.ssh/authorized_keys
    chmod 600 ${mnt}/root/.ssh/authorized_keys
    echo " done"
  fi
fi # end of if [ -z "$NEWMFSROOT" ]; then

######################################################################
# If fzg exists, copy that
######################################################################

if [ -z "$NEWMFSROOT" ]; then
  if ls /root/bin | grep . >/dev/null 2>&1 ; then
    echo -n "Copying bin/* to ${mnt}/root/bin/ ..."
    chmod 700 /root/bin
    install -d -m 700 ${mnt}/root/bin
    tar -c -f - -C /root bin | tar -C ${mnt}/root -x -f - || exiterror 1
    chmod 700 ${mnt}/root/bin/*
    echo " done"
  fi
fi # end of if [ -z "$NEWMFSROOT" ]; then

######################################################################
# If files exists, copy that
######################################################################

if [ -z "$NEWMFSROOT" ]; then
  for f in fstab hosts periodic.conf resolv.conf sysctl.conf ; do
    for suffix in .overwrite .append ; do
      if [ -e /boot/${f}${suffix} ] && [ ! -e ${mnt}/boot/${f}${suffix} ] ; then
        echo -n "Copying ${f}${suffix} to ${mnt}/boot/${f}${suffix} ..."
        cp /boot/${f}${suffix} ${mnt}/boot/${f}${suffix}
        chmod 600 ${mnt}/boot/${f}${suffix}
        echo " done"
      fi
    done
  done
fi # end of if [ -z "$NEWMFSROOT" ]; then

######################################################################
# Prompt to change root password of new install
######################################################################

while [ "$PROMPTCHANGEPASSWD" = "y" -o "$PROMPTCHANGEPASSWD" = "Y" ]; do
  echo -n "Change root password of new installation? [y/N] "
  read PROMPTCHANGEPASSWD
  case $PROMPTCHANGEPASSWD in
  y|Y)
    if [ "$MAKEMFSROOT" ]; then
      mdevice=`mdconfig -a -t vnode -f ${mfspath}`
      mount /dev/${mdevice} $mfsmnt
      mount -t devfs devfs $mfsmnt/dev
      chroot $mfsmnt /etc/rc.d/mdinit start
      chroot $mfsmnt passwd
      umount $mfsmnt/dev
      umount $mfsmnt/usr
      umount /dev/${mdevice}
      mdconfig -d -u ${mdevice#md}
    else
      chroot $mnt passwd
    fi
  ;;
  esac
done

######################################################################
# Remind not to export pool
######################################################################

if [ -z "$NEWMFSROOT" ]; then
  cat <<EOF
Don't export the ZFS pools!

You may want to set the hostname with:
        sysrc -f "${mnt}/etc/rc.conf.d/hostname" hostname="name"
See file ${mnt}/boot/loader.conf.local for more options.
EOF
fi # end of if [ -z "$NEWMFSROOT" ]; then
